\chapter{Model Based Performance Engineering of CMS DAQ System}
\label{Chapter:Implementation}

In the previous chapters the methodology of the approach was described along with information on TSDML and DEVS modeling formalism. A background information about the CMS DAQ system was also given in Chapter \ref{Chapter:DAQ}. In this chapter, details of the implementation of the approach on the CMS DAQ system will be explained. 

The first section focuses and its subsections focus on describing the system under test and how it's broken into layers. The next section describes in detail how the applications in the system are modeled in DEVS modeling formalism. The third section talks about the performance aspect captured in the models. The fourth section explains the implementation of the random input data generator used to feed data into the simulation system. The next section lays out the communication interfaces between applications. Section five describes how the system is modeled in TSDML for test generation. Sections six and seven focus mainly on performance engineering and analysis of experiment results.   

\section{System Under Test}
The system that is modeled for performance testing/engineering is a middleware based distributed system which can be depicted in three layers as shown in Figure\ref{fig:systemfigure}.

\begin{figure}
 \centering
 \includegraphics[width=0.6\textwidth]{figures/SystemFigure.png}
 % SystemFigure.png: 1179666x1179666 pixel, 0dpi, infxinf cm, bb=
 \caption{System Architecture}
 \label{fig:systemfigure}
\end{figure}

The modeled system is based on the XDAQ framework which is developed at CERN as a platform for the development of distributed data acquisition system \cite{CMSTDR}. A brief background on CMS XDAQ system is given in Chapter \ref{Chapter:DAQ}

In the upcoming sections, implementation of components of the system under test will be described. A depiction of the system under test as implemented can be seen in Figure \ref{fig:SUT}.

\begin{figure}
	\centering
		\includegraphics[width=0.90\textwidth]{figures/SUT.png}
	\caption{Implementation of System Under Test}
	\label{fig:SUT}
\end{figure}

\subsection{Application Layer}
There are four applications that exist in the application level. Those are Event Manager (EVM), Readout Unit (RU), Builder Unit (BU), and Peer Transport (PT).


Peer Transports are special applications that carry out the data transmission in the distributed programming environment. Data transmission in XDAQ and Peer Transports are explained in detail in the CMS DAQ Technical Design Report \cite{CMSTDR}. 

EVM, RU and BU applications form the RU Builder which is part of a larger system called the event builder (EVB). Given the distributed nature of the EVB, it is responsible with reading event fragments from one set of nodes and assembling them into entire events on another set of nodes. Figure \ref{fig:evbsystem} shows the event builder and how the RU Builder is connected to the rest of the system \cite{ru}. 

\begin{figure}
	\centering
		\includegraphics[width=0.90\textwidth]{figures/evbsystem.png}
	\caption{RU Builder Connected to Event Builder}
	\label{fig:evbsystem}
\end{figure}

This research is interested in the RU Builder and the applications that make up the RU Builder. Details of all the other components are given in \cite{CMSTDR}.

Event Manager (EVM) is the component which is responsible for determining the data flow in the RU Builder. Mainly, EVM assigns event id's to the events coming into the RU Builder. In addition, EVM manages the lifetime of the event id's as long as they are in the RU Builder. For this reason, EVM is the only component that knows about the status of the assigned event id's being processed in the RU Builder. EVM is in communication with all the RUs and BUs in the RU Builder \cite{CMSTDR}.

Readout Unit (RU) is the component which is responsible for reading super-fragments, keeps them in the memory until there is a request from the Builder Unit, and transmits the requested super-fragments as a response to the request \cite{CMSTDR}. 

Builder Unit (BU) is the component which is responsible for building complete events from the super-fragments that are in RUs. As BU builds complete super-fragments, it keeps them in its buffer until they are requested by the Filter Unit. Filter Unit is the computational unit of the Filter Farm which runs the physics algorithms \cite{CMSTDR}.

\subsection{Middleware Layer}
In the XDAQ architecture, the middleware layer is called the Executive Framework which is basically a XDAQ application called Executive. In a distributed manner, a copy of the Executive is run on every node that participates in data acquisition and event building. 

In the next section, how these application components are modeled in the context of Open DEVS framework will be explained.

\section{Application Simulation Models}

\subsubsection{Event Manager (EVM)}
EVM is responsible for controlling the flow of event data in the system. In the meantime, the EVM assigns event id's to the events that are generated. For the purposes of simulation, dummy event data is generated by the component called InputGenerator. Details of the InputGenerator will be explained later.

Figure \ref{fig:evm_behavior} shows the dynamic behavior of the EVM and the input/output events that it exchanges with the other applications.

\begin{figure}
	\centering
		\includegraphics[width=0.90\textwidth]{figures/evm_behavior.png}
	\caption{Dynamic Behavior and Internal FIFOs of EVM}
	\label{fig:evm_behavior}
\end{figure}


\textbf{Step 1:} When the system is enabled the first event that the EVM receives is the $bu_allocate_clear$ event from the BU. Since there are no event requests available at the beginning, this event triggers the operation of the RU BUilder. Receipt of this event affects the $clearedEventId$ and $request$ FIFOs of EVM. The incoming event may be for a new event id request, be a request for release of a used event id, or be a request for both release of a used event id and a request for new event id. Upon reciept of the event, appropriate FIFOs are filled.

At the same time, the initial request for event data is sent to the DataGenerator component. Along with the request, a parameter called $nbCredits$ is sent. This denotes the number of available free event id slots in the builder. In this first step, the number of available free event id's is the size of the freeEventIdFIFO. 

\textbf{Step 2:} If there were a request to release an event id in the previous step, the freeEventIdFIFO is populated with the released event id.

\textbf{Step 3:} EVM asks for new event data with the number of released event id's as $nbCredits$ from the DataGenerator.

\textbf{Step 4:} DataGenerator sends the generated dummy event data to the EVM. Upon receipt of the data, dummyDataFIFO is filled with the event data. 

\textbf{Step 5:} If dummyDataFIFO and freeEventIdFIFO is not empty then pairFIFO is filled with the free event id from the freeEventIdFIFO and the event number from the dummyDataFIFO.

\textbf{Step 6:} When the conditions for Step 5 are satisfied EVM also sends $ru_readout$ event to RU with the event id/event number pair. 

\textbf{Step 7:} If the requestFIFO is filled with a request from BU, and the pairFIFO is filled with a Event Id/Event Number, then EVM sends $bu_confirm$ event.

Figure \ref{fig:evmmodel1} shows the DEVS model of EVM with states and input and output events.

\begin{figure}
	\centering
		\includegraphics[width=0.95\textwidth]{figures/evmmodel1.png}
	\caption{EVM Model}
	\label{fig:evmmodel1}
\end{figure}

Initially, EVM is in WAIT state until an event is received. The events and state transition conditions are clearly indicated on the figure. EVM implements a queue called $sendQueue$ which is filled in when there is an output event to be sent out. 

\subsubsection{Readout Unit (RU)}
Readout unit is responsible for gathering the event data fragments and building super-fragments from them. Multiple fragments make up one complete event. DataGenerator generates dummy events with random fragment sizes. Figure \ref{fig:ru_behavior} shows the dynamic behavior of RU.

\begin{figure}
 \centering
 \includegraphics[width=0.90\textwidth]{figures/ru_behavior.png}
 % evm_behavior.png: 0x0 pixel, 0dpi, nanxnan cm, bb=
 \caption{Dynamic Behavior and Internal FIFOs of RU}
 \label{fig:ru_behavior}
\end{figure}


\textbf{Step 1:} The first step in the RU processing is the receipt of $ru_readout$ event from EVM. EVM sends RU a event id/event number pair for processing. RU populates its pairFIFO with event id/event number pair.

\textbf{Step 2:} RU asks the DataGenerator to send it the fragments of the event data that corresponds to the event number received from EVM.

\textbf{Step 3:} DataGenerator sends RU the number of blocks that  fragment for the specified event number is composed of. Upon reciept of the data the blockFIFO of RU is filled with the blocks received from the DataGenerator. In addition, at the same time, all blocks belonging to a single event are collected together to form event super-fragments.

\textbf{Step 4:} If the super-fragments are formed and pairFIFO is holding event id/event number pairs, then the table that is indexed by the event id from the pairFIFO and that holds all super-fragments is filled with super-fragment block.

\textbf{Step 5:} BU sends $ru_send$ event to request an event super-fragment to build. Upoxn reciept of the event, requestFIFO corresponding to the index of the BU that is requesting an event is populated.

\textbf{Step 6:} If any of the requestFIFOs is filled with a request, RU services the BU request with event super-fragments that are saved in the super-fragment table and sends out the $bu_cache$ event to BUs that requested an event.

Figure \ref{fig:rumodel1} shows the DEVS model of RU with states and input and output events.

\begin{figure}
	\centering
		\includegraphics[width=0.95\textwidth]{figures/rumodel1.png}
	\caption{RU Model}
	\label{fig:rumodel1}
\end{figure}

\subsubsection{Builder Unit (BU)}
Builder Unit (BU) is responsible for building events  An event is composed of one super-fragment from coming from the DataGenerator and N RU super-fragments where N is the number of RUs. Figure \ref{fig:bu_behavior} shows the dynamic behavior of BU.

\begin{figure}
 \centering
 \includegraphics[width=0.90\textwidth]{figures/bu_behavior.png}
 % evm_behavior.png: 0x0 pixel, 0dpi, nanxnan cm, bb=
 \caption{Dynamic Behavior and Internal FIFOs of BU}
 \label{fig:bu_behavior}
\end{figure}


\textbf{Step 1:} As BU is enabled, the first action it takes is to send initial event requests to EVM. At this point the builder is completely available to build events. BU sends the event $bu_allocate_clear$ event to EVM.

\textbf{Step 2:} BU recieves the $bu_confirm$ event from EVM. Upon receipt of the event, BU fills in the eventIdFIFO with the id's of events that are assigned to the system by EVM. 

\textbf{Step 3:} If the eventIdFIFO is not empty, BU starts the construction of the event with the first event id in the eventIdFIFO and is ready to receive fragments of that event from RUs. At this point, BU sends out the $ru_send$ event to all RUs that are participating in the event building and asks for the fragments of the event that is under construction. Moreover, at this step, if a construction of an event is complete, then the fullResourceFIFO is filled by BU. This also increases the number of events built in the builder, and completes the lifecycle of an event id/event number pair.

\textbf{Step 4:} BU recieves the $bu_cache$ event from participating RUs. Upon receipt of this event, BU fills in the blockFIFO with blocks of event under construction.

\textbf{Step 5:} If there is an event data block in the blockFIFO then BU appends event block data to the previous blocks of the same event data. When  the event building is complete the number of events built in builder is incremented and the completed event block is put into the fullResourceFIFO. In addition, the completed event id ends its lifecycle and is pushed into the discardFIFO.

\textbf{Step 6:} In the simulation system, there is no Filter Unit to process the physical importance of those events. Instead the all the events are dropped after being completed and the number of events built in BU is incremented.

\textbf{Step 7:} If the discardFIFO is not empty then the used event id is recycled and $bu_allocate_clear$ is sent to EVM if the total number of events to be built has not been reached. 

Figure \ref{fig:bumodel1} shows the DEVS model of BU with states and input and output events. 


\begin{figure}
	\centering
		\includegraphics[width=0.95\textwidth]{figures/bumodel1.png}
	\caption{BU Model}
	\label{fig:bumodel1}
\end{figure}

\subsubsection{Peer Transport (PT)}
PeerTransport is the component that is responsible for transmitting messages between applications. Figure \ref{fig:pt_behavior} shows the dynamic behavior of the PeerTransport.

\begin{figure}
 \centering
 \includegraphics[width=0.90\textwidth]{figures/pt_behavior.png}
 % evm_behavior.png: 0x0 pixel, 0dpi, nanxnan cm, bb=
 \caption{Dynamic Behavior and Internal FIFOs of PT}
 \label{fig:pt_behavior}
\end{figure}

\textbf{Step 1:} PT receives $send$ event from the Executive. Upon receipt of the event, PT fills in the msgBufferFIFO. At this point, PT knows about the communication parties and the message that is being transmitted between them. 

\textbf{Step 2:} If the message buffer is not empty, PT puts the messages in the buffer into the sendQueueFIFO and sends out the message received from the Executive to all the applications. PT does not know the contents of the message or the event that is being transmitted. PT only transmits the message to all the applications and only the application with the id that matches the destination id of the message processes the event.

Figure \ref{fig:ptmodel1} shows the DEVS model of PT with states and input and output events.

\begin{figure}
	\centering
		\includegraphics[width=0.95\textwidth]{figures/ptmodel1.png}
	\caption{PeerTransport Model}
	\label{fig:ptmodel1}
\end{figure}

\subsubsection{Executive}
Executive is the only application that resides in the middleware layer and is responsible with coordinating the communication of applications. Figure \ref{fig:executive_behavior} shows the dynamic behavior of the Executive.

\begin{figure}
 \centering
 \includegraphics[width=0.90\textwidth]{figures/executive_behavior.png}
 % evm_behavior.png: 0x0 pixel, 0dpi, nanxnan cm, bb=
 \caption{Dynamic Behavior and Internal FIFOs of Executive}
 \label{fig:executive_behavior}
\end{figure}

\textbf{Step 1:} An application that needs to send an event to another application sends the event to the Executive. Upon receipt of the message from any application on its input port, the Executive saves the message into the requestBufferFIFO. 

\textbf{Step 2:} Executive knows about the available PeerTransports to use to send messages to the desired applications. Executive sends the $send$ event to the appropriate PT. 

Figure \ref{fig:executivemodel1} shows the DEVS model of Executive with states and input and output events. 

\begin{figure}
	\centering
		\includegraphics[width=0.95\textwidth]{figures/executivemodel1.png}
	\caption{Executive Model}
	\label{fig:executivemodel1}
\end{figure}

\subsection{Processor Model}
The experimental framework also includes a processor model to implement simple scheduling. Figure \ref{fig:Processor} shows the DEVS model of the processor along with it states, transition conditions and inputs and outputs.


\begin{figure}
	\centering
		\includegraphics[width=0.99\textwidth]{figures/Processor.png}
	\caption{Processor DEVS Model}
	\label{fig:Processor}
\end{figure}

Processor receives a scheduling request from an application. Along with the scheduling request, application also sends the time it requests. The processor buffers all the scheduling requests. Then the ``$run$'' event is sent to the requesting application while the processor switches from the IDLE state to the RUN state. The life span of the RUN state of the processor becomes the amount of time requested by the application. Once the lifespan of the RUN state is elapsed, processor sends out the ``$ret$'' event to ask the application to return. Processor has several input and output ports. Every application has an input port connecting it to the processor, and there is one output port for every application to connect the processor output to the applications.

\subsection{Performance Aspect in Models}
DEVS models of applications are given in the previous sections. It's also important to note that some parameters related to the performance of the system are also captured in the application models. These parameters are mainly parameters of RU Builder applications. 

The XDAQ system is distributed as a software package by CERN which does not allow tuning of performance or modification of any performance related parameters. The tuning is done by the developers for only the case for which the system is going to be deployed for the experiment. However, for the purposes of this research, it was crucial to know the parameters which are highly probable to have an impact on the system performance. 

Upon conversations with XDAQ developers, it was made clear that so called packing parameters, and total number of blocks that make up a s-fragment are among the most important parameters that affect the performance of the system. In the original XDAQ system all packing parameters are set as $8$. Fragment sizes change during operation as different events have differing amounts of data. 

Packing parameters are captured in EVM and BU models. EVM has \textit{RU\_READOUT\_PACKING} parameter which determines how many requests need to be packed before sending a readout request to RUs. BU has \textit{EVM\_ALLOCATE\_CLEAR\_PACKING} which determines how many requests need to be packed before requesting or releasing an event id  and \textit{RU\_SEND\_PACKING} which determines how many requests need to be packed before sending s-fragment requests from RUs.

In addition to the packing parameters, BU model captures $blockFIFOCapacity$, $requestFIFOCapacity$, and $maxEvtsUnderConstruction$ which determines the maximum number of events that can be constructed in BU.

Varying event data block sizes are not captured in the application models but rather in the data generator which is explained in the next section. 

\section{Input Data Generator}
The experiment platform and the simulation engine is driven by a dummy input data generator. As stated in the previous section, differing event data fragment sizes are generated by the dummy data generator and fed into the system. 

The input data generator is modeled both in TSDML and simulation. The important aspects of the input data generator that are captured in TSDML are:

\begin{itemize}
	\item RandomDistribution: Enables selection of the type of distribution that is wanted to be used
	\item BlockSize: According to \cite{CMSTDR}, block size of an event is 4 kB and has to be captured in the so that it can be varied if needed. Number of blocks in s-fragment is a statical distribution since different events have different amounts of data \cite{CMSTDR}.
	\item NumberOfDataSources: In the CMS system, there are actually 8 total number of data sources. In order to simulate this behavior, this is also captured in TSDML.
	\item EventSizeMean: Average size of an event is 1 MB \cite{CMSTDR}. This is captured in the TSDML so that event mean can be varied and the system can be tested with varying mean event sizes.
	\item EventSizeSigma: Standard deviation for the event size.
\end{itemize}

Capturing the input data generator abstractions in TSDML also enables varying the input data parameters using a sweeper. This is illustrated in Figure \ref{fig:SweepInputGenerator}.

\begin{figure}
	\centering
		\includegraphics[width=0.70\textwidth]{figures/SweepInputGenerator.png}
	\caption{Sweeping EventSizeMean and EventSizeSigma}
	\label{fig:SweepInputGenerator}
\end{figure}

The core part of the input data generator is implemented as part of the simulation. However, it is not implemented as a DEVS model and rather implemented as a stand alone component. The type of random distribution is selected from the TSDML model and can be normal, log normal, exponential or uniform. Boost Random library is used to generate a random distribution \cite{boost}. For the random distribution generation Mersenne Twister random number generator is used. The following code snipped demonstrates how a log normal distribution was generated:

\begin{verbatim}
	//Create a Mersenne twister random number generator
	static mt19937 rng( static_cast<unsigned> (time(0)) );
	//Select distribution
	lognormal_distribution<double> lognorm_dist(_eventSizeMean, _eventSizeSigma);
\end{verbatim}

In addition to generating random distribution, input data generator component is also responsible for generating event numbers and super fragments to be consumed by the system. Figure \ref{fig:DataGenerator} shows how the input data generator component fits with the rest of the DEVS models.

\begin{figure}
	\centering
		\includegraphics[width=0.65\textwidth]{figures/DataGenerator.png}
	\caption{Input Data Generator Component View}
	\label{fig:DataGenerator}
\end{figure}

Input data generation is triggered by EVM. Number of random event sizes based on the selected distribution is generated. The total number of event sizes generated depends on the total number of events that can be built by XDAQ. EVM also triggers the super-fragment building from the generated event sizes. A super-fragment is a collection of fragments. In XDAQ system, an event is composed of several blocks (4KB each) because of the distributed nature of the system. The goal of super-fragment building is to collect all blocks of an event into one chunk called a super-fragment. The input data generator represents a super-fragment as a structure with the following fields:

\begin{itemize}
	\item Event Number
	\item Super-fragment Size = Event Size / Number of Super-fragments
	\item Number of Blocks in Super-Fragment = Super-Fragment Size / Block Size
	\item Super-fragment Number
	\item Event data blocks
\end{itemize}

In the above structure, the fields Super-fragment size and Number of Blocks In Super-fragment depend on the random event size data generated by the input generator. Event Size is the size that is generated with selected random distribution. Number of Super-fragments equals to the total number of RUs in the system. As can be observed, super-fragment is distributed equally among all RUs. 

In summary, the input data generator generates input event data that is distributed according to a selected random distribution type and provides a representation of event data in the form of a super-fragment. A super-fragment for a specific event number/event id pair is what is consumed by the simulation engine during a test run.

\section{Communication Interfaces Between Applications}

\subsection{EVM-BU Interface}

EVM and BU has two way interface. Figure \ref{fig:evm-bu} shows the events passed between EVM and BU.
\begin{figure}
	\centering
		\includegraphics[width=0.85\textwidth]{figures/evm-bu.png}
	\caption{EVM-BU Interface Diagram}
	\label{fig:evm-bu}
\end{figure}

BU starts the interaction between itself and EVM by sending event requests by sending the \textit{evm\_allocate\_clear}. The message format of the communication between EVM and BU is as follows: 
\begin{quote}
	address\#sourceId\#destinationId\#event\#data
\end{quote}

BU sends the following data along with the event:

\begin{itemize}
	\item \textbf{buAddress}: The IP address of the computer that the BU is running on
	\item \textbf{buId}: Unique identifier of the source application, BU
	\item \textbf{destinationId}: Unique identifier of the destination application
	\item \textbf{eventName}: Name of the event which is \textit{evm\_allocate\_clear} in this case
	\item \textbf{data}: Actual request message which consists of the request.
\end{itemize}

In order to form the request data, BU sets the following parameters:
\begin{itemize}
	\item BU Id: The unique identifier of the BU that is making the request.
	\item Number of Requests Packed: BU does not send one request at a time but packs multiple requests into one request. The total number of requests are sent as part of the request data.
	\item Request type: $0$ means event id request, $1$ means releasing an event id and requesting another, and $2$ means releasing an event id.
	\item Event Id: Event id to be released. If requesting an id, this is not need to be set.
	\item Event Number: Event number that is associated with the released event id. If requesting an id, this is not need to be set.
	\item Resource Id: The resource id of the BU that is making the request.
\end{itemize}

EVM receives the request from the BU and acts on it. As a result, EVM sends out the \textit{bu\_confirm} event to the requesting BU. EVM sends the following data along with the event:

\begin{itemize}
	\item \textbf{evmAddress}: The IP address of the computer that the EVM is running on
	\item \textbf{evmId}: Unique identifier of the source application, EVM
	\item \textbf{buId}: Unique identifier of the destination application, BU
	\item \textbf{event}: Name of the event which is \textit{bu\_confirm} in this case
	\item \textbf{data}: The confirmation message to BU
\end{itemize}

In order to for the confirmation data, EVM sets the following parameters:

\begin{itemize}
	\item \textbf{Event Number (eventNumber)}: Event number assigned to BU
	\item \textbf{Number of Blocks In super-fragment (nbBlocksInSuperFragment)}: Number of blocks that make up the sfragment
	\item \textbf{Block Number (blockNb)}: The position of the current block in the sfragment. It is set as $0$ at this time.
	\item \textbf{Event Id (eventId)}: Event id that is assigned to the BU.
	\item \textbf{Super-fragment Number (superFragmentNb)}: The number of the super-fragment in the block. Set as $0$ for the first set of data.
\end{itemize}


\subsection{EVM-RU Interface}

EVM and RU has a one way interface. Figure \ref{fig:evm-ru} shows the interaction between EVM and RU.

\begin{figure}
	\centering
		\includegraphics[width=0.85\textwidth]{figures/evm-ru.png}
	\caption{EVM-RU Interface Diagram}
	\label{fig:evm-ru}
\end{figure}

EVM sends RUs the \textit{readout} event. The message format of the communication between EVM and RU is as follows:

\begin{quote}
	address\#sourceId\#destinationId\#event\#data
\end{quote}

EVM sends the following data along with the event:

\begin{itemize}
	\item \textbf{Number of Elements Packed}: Total number of read out requests that is packed. EVM doesn't send events one by one. Multiple read out requests are sent.
	\item \textbf{Event Id}: Event id to be read out from the data generator.
	\item \textbf{Event Number}: Event number of the data that is read out from the data generator.
\end{itemize}


\subsection{BU-RU Interface}

BU and RU has a two way interface. Figure \ref{fig:bu-ru} shows the interaction between BU and RU.

\begin{figure}
	\centering
		\includegraphics[width=0.85\textwidth]{figures/bu-ru.png}
	\caption{BU-RU Interface Diagram}
	\label{fig:bu-ru}
\end{figure}

The message format of the communication is as follows:

\begin{quote}
	address\#sourceId\#destinationId\#event\#data
\end{quote}

BU sends RU the \textit{ru\_send} event. BU sends the following data along with the event:

\begin{itemize}
	\item \textbf{Event Id}: Event id of the event that BU is requesting
	\item \textbf{Event Number}: Event number of the event that BU is requesting
	\item \textbf{BU Resource Id}: Resource id of the BU that is going to build the event
	\item \textbf{BU Id}: Unique identifier of BU that is requesting the event data
\end{itemize}

RU sends BU the ''\textit{bu\_cache}'' event. RU sends the following data along with the event:

\begin{itemize}
	\item \textbf{Block Number}: The current block number of the event data in the data chain
	\item	\textbf{BU Resource Id}: Resource id of the BU that is going to build the event
	\item \textbf{Event Id}: Event id of the event that BU is requesting
	\item \textbf{Event Number}: Event number of the evet that BU is requesting
	\item \textbf{Number of Blocks in Super-fragment}: Total number of blocks that make up the s-fragment
	\item \textbf{Super-fragment Number}: The current s-fragment number in the s-fragment chain
\end{itemize}


\subsection{Application-Executive-PT Interface}

The Executive has one way interface with all the applications. Figure \ref{fig:exec-pt} shows the interaction between applications, executive, and peer transport.

\begin{figure}
	\centering
		\includegraphics[width=1.0\textwidth]{figures/exec-pt.png}
	\caption{Executive-Peer Transport Interface Diagram}
	\label{fig:exec-pt}
\end{figure}

Since applications need to go through the Executive to pass data to other applications, the above mentioned communication should go through the Executive. 

Executive sends PT the \textit{send} event. The message format is the same as given above since Executive does not need any extra information and transmit the data without making any modifications to it. Executive sends the data received from the application along with the event. 

PT has one way interface with the the applications. PT sends the destination application the original event that is being transmitted between the applications. PT does not also make any modifications to the data being transmitted.

\subsection{Application-Processor Interface}

Processor has two-way interface with all the applications. All applications go through the Processor for scheduling processing time. Figure \ref{fig:processor-app} shows the interaction between applications and the Processor.

\begin{figure}
	\centering
		\includegraphics[width=0.85\textwidth]{figures/processor-app.png}
	\caption{Processor-Application Interface}
	\label{fig:processor-app}
\end{figure}

Applications send the Processor the \textit{schedule} event when they request scheduling. Applications send the requested amount of time along with the event.

Processor sends the requesting application the \textit{run} event to notify it to start running. Processor does not pass any data along with the event.

Processor sends the scheduled application the \textit{ret} event to notify that the time is up and the application should return. Processor does not pass any data along with the event. 

\section{Test Generation from TSDML Models}
In Chapter \ref{Chapter:Methodology}, a description of Test Series Definition Modeling Language (TSDML) and how different components of the system under test can be modeled. This section will give an example implementation of TSDML for test generation and provide more details on the process which was shown in Figure \ref{fig:SimulationRun} in Chapter \ref{Chapter:Methodology}.

\subsection{Constructing a Test Series Definition}
In order to demonstrate an example TSDML model, construction of a test series definition for generating several test cases to experiment with different event sizes will be described from the ground up. 

\subsubsection{Application Types}
In order to construct a test series definition, applications that will be used in the definition should be created in the Type Library. Applications that are required for the test system are EVM, BU, RU and PT. The entities that are required to model an application type is already described in Section \ref{Section:TSDML} of Chapter \ref{Chapter:Methodology}.

Parameters of application types that are used in application type models come from \cite{rubuilder}. Some changes to the organizations of these parameters where appropriate to help with test generation. All application types have bi-directional communication ports to all other applications. In addition, application types include positive and negative probes as well. Figure \ref{fig:EVMModel} shows the modeling of EVM application as an application type.

\begin{figure}
	\centering
		\includegraphics[width=0.95\textwidth]{figures/EVM_tsdml.png}
	\caption{Application Type Model for EVM}
	\label{fig:EVM_tsdml}
\end{figure}

It's important to note that application types are modeled without any parameter values. This way, when an application type is used (instantiated) in a test series definition it can be specialized by changing its parameter values. All other application models are similar to EVM.

\subsubsection{Test Series Definition}
The test series definition is the main part of the design as the name implies. There are three different aspects that need to be modeled to complete a test series definition so that test cases can be generated.

In a test series definition, several ways exist to generate test cases to experiment with the system in different ways. One way to generate different series of test cases is to change the structure of the system using replicators. This is done in the \textit{\textbf{Test Series Definition View}}. The Test Series Definition view is where the applications that were defined in the application library are used. Applications from the type library are sub-typed so that values for application parameters can be manipulated as desired. In addition, this way, it is not possible to make changes to the application type, e.g. no parameter or port can be deleted. This is to make sure that the same application type is used in all test series definitions with only the desired parameter value changes. 

\begin{figure}
	\centering
		\includegraphics[width=0.90\textwidth]{figures/TSDModel.png}
	\caption{Test Series Definition View of a Test Series Definition with Replicators}
	\label{fig:TSDModel}
\end{figure}

Figure \ref{fig:TSDModel} shows how the Test Series Definition View looks.Sub-types of the applications already modeled in the type library are used in the test series definition. It can be seen from Figure \ref{fig:TSDModel} that there is an iterator connected to a replicator which is connected to applications RU and BU. This denotes that there will be as many test cases generated from this test series definition as the value of the Iterator. Moreover, in each of these test cases, applications RU and BU will be replicated by the value of the replicator. In this specific example, in each test case the instances of RU and BU will be doubled. Figure \ref{fig:TSDItRep} shows the values of the Iterator and the Replicator. It's important to note that only the applications RU and BU will be replicated in generated test cases since the Replicator is only attached to these applications. 

\begin{figure}
	\centering
		\includegraphics[width=1.00\textwidth]{figures/TSDItRep.png}
	\caption{Iterator and Replicator Values}
	\label{fig:TSDItRep}
\end{figure}

In the replication process, in addition to application instances, connections between applications need to be replicated as well. For this purpose, several Connectors are used to connect the applications on their bi-directional ports. In this test series definition, all applications are connected to each other. As can be seen in Figure \ref{fig:ConnTSD}, the Connector between applications RU and BU is called RU-BU and its connection rule is set to "`1"'. This means that all instances of RU and BU in generated test cases are connected to each other. The connection rules of connectors RU-PT, RU-EVM, BU-PT, BU-EVM, and EVM-PT are also set to "`1"'. However, since the Replicator is not connected to applications PT, EVM, and BU there will always be only one instance of these applications, which are connected to each other, in all generated test cases. Another example of setting different connection rules was explained in Section \ref{Section:TSDML} of Chapter \ref{Chapter:Methodology}. 

\begin{figure}
	\centering
		\includegraphics[width=0.95\textwidth]{figures/ConnTSD.png}
	\caption{Connection Rule is 1: All instances are connected}
	\label{fig:ConnTSD}
\end{figure}

\begin{figure}
	\centering
		\includegraphics[width=1.00\textwidth]{figures/TSDSweep.png}
	\caption{Sweeping Application Parameter Value}
	\label{fig:TSDSweep}
\end{figure}

Another way to generate different series of test cases is to vary ("`\textit{sweep}"') application parameter values for each generated test case. This can be done using a Sweeper. Sweeper is present in the Test Definition View of an application model in the Test Series Definition. Figure \ref{fig:TSDSweep} shows usage of Sweeper to generate test cases with varying value for the $RU\_SEND\_PACKING$. The Sweeper has a function to double the value of $RU\_SEND\_PACKING$. Sweeper is also connected to a reference to the Iterator of the Test Series Definition which ensures that the value of the parameter will be doubled for each generated test case. 

Similar to varying application parameter values, Sweeper can also be used to vary parameters of the Input Generator of the Test Series Definition. This is especially useful to experiment with varying event sizes. Figure \ref{fig:TSDInput} demonstrates how this is done.  As can be seen in the figure, for each generated test case, mean of event size will be increased by 4 megabits.

Also in the same figure, the RandomDistribution entity can be seen. Input Generator will create random event sizes with the selected random distribution type.

\begin{figure}
	\centering
		\includegraphics[width=1.00\textwidth]{figures/TSDInput.png}
	\caption{Sweeping Event Size in Input Generator}
	\label{fig:TSDInput}
\end{figure}

So far a test series definition is defined from the Test Series Definition View which enabled creating variations on the system structure and behavior to generate series of test cases. Another aspect of creating a test series definition is deployment. The \textit{\textbf{Deployment View}} enables deploying the system. In order to start a deploying the applications, a Node in Resource Library needs to be modeled. Figure \ref{fig:TSDNode} shows a simple model of a node in the resource library.

\begin{figure}
	\centering
		\includegraphics[width=1.00\textwidth]{figures/TSDNode.png}
	\caption{Model of a Node in Resource Library}
	\label{fig:TSDNode}
\end{figure}

Figure \ref{fig:TSDDeploy} shows a possible deployment for the test series definition under construction. The deployment view has a reference to the node that is created in the resource library. All the applications that were modeled in the Test Series Definition view are also visible in Deployment View and they are all connected to the Executive. The Executive represents the middleware layer which applications need to be deployed on in order to operate. The Executive also needs to be deployed on a node through a port on which it will run. As can be seen in Figure \ref{fig:TSDDeploy}, the Executive is connected to the Port which is connected to the NIC of Node1. It's important to point out that Port is a logical entity and models the endpoint which will be available to run the Executive on Node1.

\begin{figure}
	\centering
		\includegraphics[width=1.00\textwidth]{figures/TSDDeploy.png}
	\caption{Deployment View of Test Series Definition}
	\label{fig:TSDDeploy}
\end{figure}

Test Series Definition View and Deployment View covered the behavioral/configuration and deployment aspects of the test series definition. \textit{\textbf{Performance View}} is where the performance related aspects are added. The main entity in the Performance View is the Performance Probe. Figure \ref{fig:TSDProbe} shows how performance probes are connected to indicate measurement points.

\begin{figure}
	\centering
		\includegraphics[width=1.00\textwidth]{figures/TSDProbe.png}
	\caption{Performance View of Test Series Definition}
	\label{fig:TSDProbe}
\end{figure}

In this specific example, one performance probe is connected to a negative probe end of application RU and the positive probe end on the application BU. This denotes that a performance measurement for a selected metric will be made between the output of RU and the input of BU. Another performance probe is connected between the negative probe end of application BU and positive probe end of application EVM. This denotes that a performance measurement for a selected metric will be made between the output of the application BU and the output of EVM. Figure \ref{fig:TSDProbeAdv} shows a more through use of performance probes.

\begin{figure}
	\centering
		\includegraphics[width=1.00\textwidth]{figures/TSDProbeAdv.png}
	\caption{Metric Choices for Performance Probe}
	\label{fig:TSDProbeAdv}
\end{figure}

\subsection{Test Case Generation}
Application simulation models and TSDML models are created. These models represent the behavioral, structural, and performance aspects of the system under test under the described abstractions. As described throughout this document, TSDML models will be used for generating series of test cases to be executed on the DEVS simulation engine. 

Test cases that will be generated from test series definitions in TSDML are XML configuration files that will configure the simulation engine with the information captured in the test series definitions. Figure \ref{fig:TSDTestGen1} shows the process of test case generation. The XML configurations generated from test test series definition need to be fed into the simulation engine.

\begin{figure}
	\centering
		\includegraphics{figures/TSDTestGen1.png}
	\caption{Test Generation Process}
	\label{fig:TSDTestGen1}
\end{figure}

The interaction between test cases and the simulation engine requires a test case format that can be read by the simulation engine. For this purpose, a schema for XML test cases were created. Figure \ref{fig:TSDConfigSchema} shows the test schema of the test cases that will be generated by the test series definition TSDML and read by the simulation engine. As can be seen in the figure there are five main tags which collect the information in the model:

\begin{enumerate}
	\item \verb|<test>|: the root of the test case.
	\item \verb|<test_case>|: captures the information about the test case that will guide saving results to a database.
	\item \verb|<input_generator>|: configures the input generator. This tag contains the parameters of the Input Generator. There is a one-to-many relationship between the input generator and contained parameters.
	\item \verb|<deployment>|: captures the information modeled in the Deployment View of test series definition model. Deployment contains a cpu which in turn contains the executive and which contains the deployed applications. There is one-to-many relationship among all contained elements.
	\item \verb|<dataflow>|: captures the connection information of the applications in the test series definition. 
	\item \verb|<performance>|: captures the performance probes modeled in the Performance View of test series definition model. There is a one-to-many relationship between performance tag and contained probes.
\end{enumerate}

\begin{figure}
	\centering
		\includegraphics[width=0.90\textwidth]{figures/TSDConfigSchema.png}
	\caption{Test Case Schema}
	\label{fig:TSDConfigSchema}
\end{figure}

\subsection{Test Execution}
In the context of the approach described here, execution of test cases means running a DEVS simulation using DEVS models configured by the test cases generated from the test series definition TSDML model.

Figure \ref{fig:TSDExecution} shows the complete process of test generation and execution. Test Execution Engine seen in the figure is responsible for orchestrating the execution of all the generated test cases one by one on the simulation framework. It does not do any processing or manipulation on the test case format. Any single test case can directly be run on the simulation framework without passing through the Test Execution Engine.

The input to the DEVS Framework is the generated test case whose format was described in the previous subsection. Upon receiving a test case, behavioral DEVS models are configured with the information captured in the test case. In addition to the behavioral DEVS models, Input Generator and Performance Monitor components are also configured with the input test case. At the end of each run, Performance Monitor stores the performance results in the database. The following list shows the mapping from the test case to the DEVS framework:

\begin{itemize}
	\item \verb|<test_case>|: configures and initializes the database
	\item \verb|<deployment>|: configures how application DEVS models are deployed in the middleware (Executive) application DEVS model
	\item \verb|<dataflow>|: configures a coupled DEVS model by connecting the atomic DEVS models 
	\item \verb|<performance>|: configures performance monitor with the desired measurement points
\end{itemize}

\begin{figure}
	\centering
		\includegraphics[width=0.90\textwidth]{figures/TSDExecution.png}
	\caption{Test Case Execution}
	\label{fig:TSDExecution}
\end{figure}


\section{Results and Analysis}
****TODO****

\textbf{Varying Event Size}
An experiment was setup to observe the effect of event size variation on the system performance metrics. Average event size was varied for a 1x1 system, 2x2 system and a 4x4 system. This way, it will be possible to observe whether a larger system copes with increasing average event size. 


\section{Closing the Loop: Performance Engineering}
****TODO****

\section{Summary}
****TODO****
